# pai-tl
Tech Leader / Team Leader的技术积累

[TOC]

# 1 开发规范与约定
参考https://github.com/alibaba/p3c

## 1.1 命名约定
搭建项目结构的起步过程，应用命名规范、模块的划分、目录（包）的命名
具体规范包括包命名、类的命名、接口命名、方法命名、变量命名、常量命名

1.图中默认上层依赖于下层，箭头关系表示可直接依赖，如:开放接口层可以依赖于Web 层，也可以直接依赖于 Service 层，依此类推:
![avatar](https://github.com/alibaba/p3c/blob/master/p3c-gitbook/images/alibabaLevel.png)
开放接口层:可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。

终端显示层:各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。

Web 层:主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。

Service 层:相对具体的业务逻辑服务层。

Manager 层:通用业务处理层，它有如下特征:
1) 对第三方平台封装的层，预处理返回结果及转化异常信息;
2) 对Service层通用能力的下沉，如缓存方案、中间件通用处理;
3) 与DAO层交互，对多个DAO的组合复用。

DAO 层:数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。

外部接口或第三方平台:包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。

2.(分层异常处理规约)在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进 行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印 日志，因为日志在 Manager/Service 层一定需要捕获并打印到日志文件中去，如果同台服务 器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能 带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上 抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。

3.分层领域模型规约:DO、DTO/BO、VO
DO(Data Object):此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。（do是Java关键字，改为PO包，P即persist）
DTO(Data Transfer Object):数据传输对象，Service 或 Manager 向外传输的对象。
BO(Business Object):业务对象，由 Service 层输出的封装业务逻辑的对象。
AO(ApplicationObject):应用对象，在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。 
VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象。
Query:数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。

## 1.2 IDE代码模板
https://github.com/alibaba/p3c/blob/master/p3c-formatter/eclipse-codestyle.xml

## 1.3 Maven使用约定
所有二方库、三方库的版本统一定义到parent pom里，这样来所有业务应用工程统一继承parent pom里所指定的二方库、三方库的版本，统一框架与工具的版本(Spring、Apache commons工具类、日志组件、JSON处理、数据库连接池等)，同时生产环境禁用SNAPSHOT版本。

## 1.4 代码Commit约定
基于Angular Commit Message规范生成统一的ChangeLog。

阮一峰老师的《Commit message 和 Change log 编写指南》，http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html

## 1.5 API约定
RPC服务接口的返回值ResultDTO,具体代码io.github.homepy.pai.dto.ResultDTO。

HTTP RestFul接口,额外关注一下加解密规范和签名规范、版本管理规范。

## 1.6 异常处理约定
service服务层捕获的异常主要包括BusinessException(业务异常)、RetriableException (可重试异常) 。

定义一个公共异常拦截器，对业务异常、重试异常进行统一处理，对于可重试的异常调用的服务接口需要保证其幂等性。

## 1.7 分支开发约定
分支的定义（master、develop、release、hotfix、feature）
分支命名规范
checkout、merge request流程
提测流程
上线流程
Hotfix流程

## 1.8 日志约定
在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打印到日志文件中去。

## 1.9 MySQL开发约定

## 1.10 工具与框架
对开发过程中所用到的公共组件进行了统一抽象与封装，包括 dao 层框架mybatis、cache 组件 jetcache、httpclien t组件、common-tools (公共工具)，同时抽取出全局唯一ID、分布式锁、幂等等公共组件



# 2 开发流程

## 2.1 需求管理
第一步就是要梳理不同来源的需求，得到一些核心需求，摒除价值不大的需求。
最重要的就是对发散性需求的管理，谨慎变更。

## 2.2 技术架构评审

1. 技术选型：为什么选用A组件不选用B、C组件，A是开源的，开源协议是啥？基于什么语言开发的，出了问题我们自身是否能够维护？性能方面有没有压测过？这些所有问题作为技术选型我们都需要考虑清楚，才能做最终决定。

2. 高性能：产品对应的TPS、QPS和RT是多少？设计上会做到的TPS、QPS和RT是多少？而实际上我们整体随着数据量的增大系统性能会不会出现明显问题？随着业务量、数据量的上升，我们的系统的性能如何去进一步提高？系统哪个环节会是最大的瓶颈？是否有抗突发性能压力的能力，大概可以满足多少的TPS和QPS，怎么去做来实现高性能，这些问题都需要我们去思考。

3. 高可用：是否有单点的组件，非单点的组件如何做故障转移？是否考虑过多活的方案？是否有数据丢失的可能性？数据丢失如何恢复？出现系统宕机情况，对业务会造成哪些影响？有无其他补救方案？这些问题需要想清楚，有相应的解决方案。

4. 可扩展性：A和B的业务策略相差无几，后面会不会继续衍生出C的业务策略，随着业务的发展哪些环节可以做扩展，如何做扩展？架构设计上需要考虑到业务的可扩展性。

5. 可伸缩性：每个环节的服务是不是无状态的？是否都是可以快速横向扩展的？扩容需要怎么做手动还是自动？扩展后是否可以提高响应速度？这所有的问题都需要我们去思考清楚，并有对应的解决方案。

6. 弹性处理：消息重复消费、接口重复调用对应的服务是否保证幂等？是否考虑了服务降级？哪些业务支持降级？支持自动降级还是手工降级？是否考虑了服务的超时熔断、异常熔断、限流熔断？触发熔断后对客户的影响？服务是否做了隔离，单一服务故障是否影响全局？这些问题统统需要我们想清楚对应的解决方案，才会进一步保证架构设计的合理性。

7. 兼容性：上下游依赖是否梳理过，影响范围多大？怎么进行新老系统替换？新老系统能否来回切换？数据存储是否兼容老的数据处理？如果对你的上下游系统有影响，是否通知到上下游业务方？上下游依赖方进行升级的方案成本如何最小化？这些问题需要有完美的解决方案，稍有不慎会导致故障。

8. 安全性：是否彻底避免SQL注入和XSS？是否有数据泄露的可能性？是否做了风控策略？接口服务是否有防刷保护机制？数据、功能权限是否做了控制？小二后台系统是否做了日志审计？数据传输是否加密验签？应用代码中是否有明文的AK/SK、密码？这些安全细节问题需要我们统统考虑清楚，安全问题任何时候都不能轻视。

9. 可测性：测试环境和线上的差异多大？是否可以在线上做压测？线上压测怎么隔离测试数据？是否有测试白名单功能？是否支持部署多套隔离的测试环境？测试黑盒白盒工作量的比例是怎么样的？新的方案是否非常方便测试，在一定程度也需要考量。

10. 可运维性：系统是否有初始化或预热的环节？数据是否指数级别递增？业务数据是否需要定期归档处理？随着时间的推移如果压力保持不变的话系统需要怎么来巡检和维护？业务运维方面的设计也需要充分考虑到。

11. 监控与报警：对外部依赖的接口是否添加了监控与报警？应用层面系统内部是否有暴露了一些指标作监控和报警？系统层面使用的中间件和存储是否有监控报警？只有充分考虑到各个环节的监控、报警，任何问题会第一时间通知到研发，阻止故障进一步扩散。

## 2.3 代码评审
代码质量包括功能性代码质量和非功能性代码质量。
功能质量大多通过测试能够去发现问题；
非功能性代码质量用户不能直接体验到这种质量的好坏，代码质量不好，最直接的“受害者”是开发者或组织自身，因为代码质量好坏直接决定了软件的可维护性成本的高低。
代码质量应该更多的应该从可测性，可读性，可理解性，容变性等代码可维护性维度去衡量。

1) 确认代码功能
2) 编码规范
3) 潜在的BUG
4) 文档和注释
5) 重复代码
6) 复杂度
7) 监控与报警
8) 测试覆盖率

## 2.4 发布计划评审
涉及到10人日以上的项目，必须有明确的发布计划，并组织项目成员统一参加项目发布计划review，发布计划主要包含如下几点：

1）明确是否有外部依赖接口，如有请同步协调好业务方；
2）发布前配置确认包括配置文件、数据库配置、中间件配置等各种配置，尤其各种环境下的差异化配置项；
3）二方库发布顺序，是否有依赖；
4）应用发布顺序；
5）数据库是否有数据变更和订正，以及表结构调整；
6）回滚计划，必须要有回滚计划，发布出现问题要有紧急回滚策略；
7）生产环境回归测试重点Case。

# 3 技术规划与管理
## 3.1 系统健康度巡检
系统指标：系统CPU、负载、内存、网络、磁盘有无异常情况波动，确认是否由发布导致，还是系统调用异常。
慢接口：通常rt大于3s的接口需要重点关注，极端并发场景下容易导致整个系统雪崩。
慢查询：MYSQL慢查询需要重点关注，随着数据量上涨，需要对慢查询进行优化。
错误日志：通过错误日志去发现系统隐藏的一些bug，避免这些bug被放大，甚至极端情况下会导致故障。

## 3.2 技术规划
再次规划 2.2 技术架构评审 中的内容
